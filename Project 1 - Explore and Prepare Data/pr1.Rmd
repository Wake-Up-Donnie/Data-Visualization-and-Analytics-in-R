---
title: 'Project 1: Explore and Prepare Data'
subtitle: |-
  CSE6242 - Data and Visual Analytics - Spring 2017
  author: 'Tyler Bobik'
  GT_Account_Name: 'tbobik3'
  Due: Sunday, March 5, 2017 at 11:59 PM UTC-12:00 on T-Square
  output: pdf_document
  pdf_document: default
  html_notebook: default
  html_document: default
---

_Note: This project involves getting data ready for analysis and doing some preliminary investigations. Project 2 will involve modeling and predictions, and will be released at a later date. Both projects will have equal weightage towards your grade._

# Title

Name: Tyler Bobik

GT Account Name: tbobik3

# Data

In this project, you will explore a dataset that contains information about movies, including ratings, budget, gross revenue and other attributes. It was prepared by Dr. Guy Lebanon, and here is his description of the dataset:

> The file [`movies_merged`](https://s3.amazonaws.com/content.udacity-data.com/courses/gt-cs6242/project/movies_merged) contains a dataframe with the same name that has 40K rows and 39 columns. Each row represents a movie title and each column represents a descriptor such as `Title`, `Actors`, and `Budget`. I collected the data by querying IMDb’s API (see [www.omdbapi.com](http://www.omdbapi.com/)) and joining it with a separate dataset of movie budgets and gross earnings (unknown to you). The join key was the movie title. This data is available for personal use, but IMDb’s terms of service do not allow it to be used for commercial purposes or for creating a competing repository.

# Objective

Your goal is to investigate the relationship between the movie descriptors and the box office success of movies, as represented by the variable `Gross`. This task is extremely important as it can help a studio decide which titles to fund for production, how much to bid on produced movies, when to release a title, how much to invest in marketing and PR, etc. This information is most useful before a title is released, but it is still very valuable after the movie is already released to the public (for example it can affect additional marketing spend or how much a studio should negotiate with on-demand streaming companies for “second window” streaming rights).

# Instructions
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. Open this file in RStudio to get started.

When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
x = 1:10
print(x^2)
```

Plots appear inline too:
```{r}
plot(x, x^2, 'o')
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file).

Please complete the tasks below and submit this R Markdown file (as **pr1.Rmd**) as well as a PDF export of it (as **pr1.pdf**). Both should contain all the code, output, plots and written responses for each task.

# Setup

## Load data

Make sure you've downloaded the [`movies_merged`](https://s3.amazonaws.com/content.udacity-data.com/courses/gt-cs6242/project/movies_merged) file and it is in the current working directory. Now load it into memory:

```{r}
load('movies_merged')
```

This creates an object of the same name (`movies_merged`). For convenience, you can copy it to `df` and start using it:

```{r}
df = movies_merged
cat("Dataset has", dim(df)[1], "rows and", dim(df)[2], "columns", end="\n", file="")
colnames(df)
```

## Load R packages

Load any R packages that you will need to use. You can come back to this chunk, edit it and re-run to load any additional packages later.

```{r}
library(ggplot2)
library(GGally)
library(stringr)
library(stringi)
library(tm)
library(knitr)
```

If you are loading any non-standard packages (ones that have not been discussed in class or explicitly allowed for this project), please mention them below. Include any special instructions if they cannot be installed using the regular `install.packages('<pkg name>')` command.

**Non-standard packages used**: None

# Tasks

Each task below is worth **10** points, and is meant to be performed sequentially, i.e. do step 2 after you have processed the data as described in step 1. Total points: **100**

Complete each task by implementing code chunks as described by `TODO` comments, and by responding to questions ("**Q**:") with written answers ("**A**:"). If you are unable to find a meaningful or strong relationship in any of the cases when requested, explain why not by referring to appropriate plots/statistics.

It is OK to handle missing values below by omission, but please omit as little as possible. It is worthwhile to invest in reusable and clear code as you may need to use it or modify it in project 2.

## 1. Remove non-movie rows

The variable `Type` captures whether the row is a movie, a TV series, or a game. Remove all rows from `df` that do not correspond to movies.

```{r}
df = df[df$Type == "movie",]
df$Runtime[df$Runtime == 'N/A'] = NA
```

**Q**: How many rows are left after removal? _Enter your response below._
**A**:40,000

## 2. Process `Runtime` column

The variable `Runtime` represents the length of the title as a string. Write R code to convert it to a numeric value (in minutes) and replace `df$Runtime` with the new numeric column.

```{r}
runtime_String = function(col){
        length_Col = seq_along(col)
        convertedToMin = c()
        for(i in length_Col){
                split_On_Spaces = strsplit(df$Runtime[i], ' ')[[1]]
                if((is.na(split_On_Spaces[2]))){
                        convertedToMin = append(convertedToMin, NA)
                }
                else if((grepl("min", split_On_Spaces[2]))){
                        convertedToMin = append(convertedToMin,(as.numeric(split_On_Spaces[1])))
                        
                }
                else if((grepl("h", split_On_Spaces[2]))){
                        convertedToMin = append(convertedToMin,(as.numeric(split_On_Spaces[1])) * 60 + (as.numeric(split_On_Spaces[3])))
                        #print (convertedToMin)
                }
        }
        return (convertedToMin)
}
df$Runtime = (runtime_String(df$Runtime))
df = subset(df, !is.na(Runtime))
```

Now investigate the distribution of `Runtime` values and how it changes over years (variable `Year`, which you can bucket into decades) and in relation to the budget (variable `Budget`). Include any plots that illustrate.

```{r}
qplot(df$Runtime,
      geom="histogram",
      binwidth = 5,  
      main = "Histogram for Runtime(In Minutes) in Movies", 
      xlab = "Runtime (In Minutes)",  
      fill=I("red"), 
      col=I("blue")) + scale_x_continuous(name = "Runtime (In Minutes)", breaks = seq(0, 900, by = 60))

ggplot(data=df,aes(x=Year,y=Runtime))+
        geom_point(alpha=1/10,position="jitter")+
        scale_y_continuous(limits = c(0,250)) + 
        scale_x_continuous(name = "Years by Decade", breaks = seq(1888, 2018, by = 10)) +
        ggtitle("Runtime (Minutes) Vs Movie Year (Decade)") 

df = subset(df, !is.na(Budget))

ggplot(df, aes(x = df$Runtime, y = df$Budget)) + 
        scale_x_continuous(name = "Runtime (Minutes)", breaks = seq(0, 325, by = 25)) + 
        geom_bar(stat = "identity") + 
        labs(y="Budget", title="Budget vs. Runtime Barplot")



```

_Feel free to insert additional code chunks as necessary._

**Q**: Comment on the distribution as well as relationships. Are there any patterns or trends that you can observe?

**A**: As you can see in the histogram graph, “Histogram for Runtime(In Minutes) in Movies” the most common runtime for movies is around 100 minutes and it is lefty skewed, there are a very small number of movies with runtime over 180min.
In the scatterplot titled “Runtime (Minutes) Vs Movie Year (Decade)” you can see some places where clusters of points are more common. You can see that from 1888 till around 1908 movies were commonly shorter in time with none over 25 min runtimes and that there were not many movies made. You can then see from 1928 – 1968 that there were two clusters of shorter films, one around 20min and the other around 10min, additionally there were longer films than in previous decades along with the face that more movies were made in general. From 1968 – 1998 there were few shorter movies with many longer films centered around 75min – 110min. From 1998 – 2004 a cluster of shorter moves appeared which lengths were centered around 1min – 25min. In this date range there were many longer films and the cluster was centered from 70min-125min. In the year range 2004 – 2018 there seems to be less movies made in general and the ones that were made ending up in the time range 75min – 125min.
In the graph labeled “Budget Vs. Runtime Barplot” you can see the histogram is skewed to the left slightly showing that there are some movies with longer runtimes that are outliers. Additionally, you can see that the movies that are around 100 – 125 had the largest budgets which is interesting because I would think that possibly the longer movies would need a much higher budget. It is clear here that the shorter movies 0 – 75min have very low budgets so I wrongly assumed that the longer the movie, the higher the budget would need to be.



## 3. Encode `Genre` column

The column `Genre` represents a list of genres associated with the movie in a string format. Write code to parse each text string into a binary vector with 1s representing the presence of a genre and 0s the absence, and add it to the dataframe as additional columns. Then remove the original `Genre` column.

For example, if there are a total of 3 genres: Drama, Comedy, and Action, a movie that is both Action and Comedy should be represented by a binary vector <0, 1, 1>. Note that you need to first compile a dictionary of all possible genres and then figure out which movie has which genres (you can use the R `tm` package to create the dictionary).

```{r}
# TODO: Replace Genre with a collection of binary columns
df$Genre[df$Genre == 'N/A'] = NA
df = subset(df, !is.na(Genre))
require(tm)

myReader = readTabular(mapping = list(ImbdID= "imdbID", Content = "Genre"))
mycorpus = Corpus(VectorSource(df$Genre))

dtmm = tm_map(mycorpus, FUN = tm_reduce, tmFuns = list(content_transformer(tolower), removePunctuation, removeNumbers, stripWhitespace), stemDocument)
workingdtm = DocumentTermMatrix(dtmm)
workingdtm_df = data.frame(as.matrix(workingdtm))

workingdtm_df$imdbID = df$imdbID

df = merge(df,workingdtm_df,by="imdbID")
df = df[-c(7)]
```

Plot the relative proportions of movies having the top 10 most common genres.

```{r}
# TODO: Select movies from top 10 most common genres and plot their relative proportions
amountOfTimesOccured = colSums(as.matrix(workingdtm))
sort = order(amountOfTimesOccured,decreasing=TRUE)
sortedDataframe = data.frame(term=names(amountOfTimesOccured),occurrences=amountOfTimesOccured)

sortedDataframe$occurrences = (sortedDataframe$occurrences / length(df$imdbID))
sortedDataframe$occurrences = (sortedDataframe$occurrences * 100)


sortedDataframe = sortedDataframe[order(sortedDataframe$occurrences),]
#top 10
sortedDataframe = tail(sortedDataframe,10)
#Order decending
sortedDataframe = sortedDataframe[order(-sortedDataframe$occurrences),]
ggplot(sortedDataframe , aes(x = reorder(term, -occurrences), y = occurrences)) + 
        geom_bar(stat="identity") + 
        theme(axis.text.x=element_text(angle=45, hjust=1)) +
        labs(x="Top 10 Genres", y="Proportion", title="Top 10 Genre Proportions")
```

Examine how the distribution of `Runtime` changes across genres for the top 10 most common genres.

```{r}
# TODO: Plot Runtime distribution for top 10 most common genres
total_runtime_drama = sum(df$Runtime[which(df$drama==1)])
total_runtime_comedy = sum(df$Runtime[which(df$comedy==1)])
total_runtime_action= sum(df$Runtime[which(df$action==1)])
total_runtime_adventure = sum(df$Runtime[which(df$adventure==1)])
total_runtime_crime = sum(df$Runtime[which(df$crime==1)])
total_runtime_romance = sum(df$Runtime[which(df$romance==1)])
total_runtime_thriller = sum(df$Runtime[which(df$thriller==1)])
total_runtime_horror = sum(df$Runtime[which(df$horror==1)])
total_runtime_scifi = sum(df$Runtime[which(df$scifi==1)])
total_runtime_mystery = sum(df$Runtime[which(df$mystery==1)])

top_ten_genre_labels = c("drama", "comedy", "action", "adventure", "crime", "romance", "thriller", "horror", "scifi", "mystery")
totals_top_ten_runtime_genre = c(total_runtime_drama,
                                 total_runtime_comedy,
                                 total_runtime_adventure,
                                 total_runtime_action,
                                 total_runtime_crime,
                                 total_runtime_romance,
                                 total_runtime_thriller,
                                 total_runtime_horror,
                                 total_runtime_scifi,
                                 total_runtime_mystery)
top10runtime = data.frame(genre=top_ten_genre_labels,runtime=totals_top_ten_runtime_genre)
ggplot(top10runtime, aes(x = reorder(genre, -runtime), y = runtime)) + 
        geom_bar(stat="identity") + 
        labs(x="Top 10 Genres", y="Total Runtime", title="Total Runtime Vs Top 10 Genres")

mean_runtime_drama = mean(df$Runtime[which(df$drama==1)])
mean_runtime_comedy = mean(df$Runtime[which(df$comedy==1)])
mean_runtime_action= mean(df$Runtime[which(df$action==1)])
mean_runtime_adventure = mean(df$Runtime[which(df$adventure==1)])
mean_runtime_crime = mean(df$Runtime[which(df$crime==1)])
mean_runtime_romance = mean(df$Runtime[which(df$romance==1)])
mean_runtime_thriller = mean(df$Runtime[which(df$thriller==1)])
mean_runtime_horror = mean(df$Runtime[which(df$horror==1)])
mean_runtime_scifi = mean(df$Runtime[which(df$scifi==1)])
mean_runtime_mystery = mean(df$Runtime[which(df$mystery==1)])

mean_top_ten_runtime_genre = c(mean_runtime_drama,
                                 mean_runtime_comedy,
                                 mean_runtime_adventure,
                                 mean_runtime_action,
                                 mean_runtime_crime,
                                 mean_runtime_romance,
                                 mean_runtime_thriller,
                                 mean_runtime_horror,
                                 mean_runtime_scifi,
                                 mean_runtime_mystery)

top10meanruntime = data.frame(genre=top_ten_genre_labels,runtime=mean_top_ten_runtime_genre)
ggplot(top10meanruntime, aes(x = reorder(genre, -runtime), y = runtime)) + 
        geom_bar(stat="identity") + 
        labs(x="Top 10 Genres", y="Mean Runtime", title="Mean Runtime Vs Top 10 Genres")
```

**Q**: Describe the interesting relationship(s) you observe. Are there any expected or unexpected trends that are evident?

**A**: I think that it is interesting that top 10 ordering for each genre stays about the same when comparing the “Top 10 Genre Proportion” and the “Total Runtime Vs Top 10 Genres” graphs. The only exception is that the total runtime for action and adventure is switched on the runtime graph where there are more action movies than adventure movies in the “Top 10 Genre Proportion” graph. I would say that this is an unexpected result because I would not think that the proportion of the movies and the total runtimes would line up the way they do.

After thinking about this for a bit I realized that using the total runtime most likely is not the right way to compare the runtimes across different genre’s. This is because the higher proportioned of movies would obviously have higher total runtimes since there are more of them. After realizing this I decided to use the mean instead of just the pure sum.
You can see the results from this change in the graph labeled "Mean Runtime Vs Top 10 Genres", you can see that comedy went from the second highest runtime to the second to last. Additionally, I thought it was interesting that they all have pretty similar runtimes using the mean.


## 4. Eliminate mismatched rows

The dataframe was put together by merging two different sources of data and it is possible that the merging process was inaccurate in some cases (the merge was done based on movie title, but there are cases of different movies with the same title). The first source’s release time was represented by the column `Year` (numeric representation of the year) and the second by the column `Released` (string representation of release date).

Find and remove all rows where you suspect a merge error occurred based on a mismatch between these two variables. To make sure subsequent analysis and modeling work well, avoid removing more than 10% of the rows that have a `Gross` value present.

```{r}
# TODO: Remove rows with Released-Year mismatch
missmached = function(col1,col2){
        seq_Col = seq_along(col1)
        total_gross_entries = c()
        notequal = c()
        split = c()
        for(i in seq_Col){
                split_On_Dashes = strsplit(as.character(df$Released[i]), '-')[[1]]
                if(is.na(split_On_Dashes[1])){
                        split_On_Dashes = 0
                        split = append(split,as.numeric(split_On_Dashes))
                }
                else{
                        split = append(split,as.numeric(split_On_Dashes[1]))
                }
        }
        return (split)
}
splitReleased = missmached(df$Released, df$Year)
compareYearVsReleasedYear = df$Year == splitReleased
combinedDf = data.frame(df$Title, df$imdbID, df$Gross, df$Year, splitReleased, compareYearVsReleasedYear)

ten_percent = round((length(df$Gross) * .10))
print (ten_percent)
combinedDf = subset(combinedDf, splitReleased != 0)
combinedDf = subset(combinedDf, compareYearVsReleasedYear== FALSE)
combinedDf = combinedDf[1:ten_percent,]
df = df[!(df$imdbID %in% combinedDf$df.imdbID),]
df = subset(df, !is.na(Released))
```

**Q**: What is your precise removal logic and how many rows did you end up removing?

**A**: Before I removed any rows for this problem it should be noted that there is now 4,517 rows remaining in my dataframe. What I did was do a string split on the “-“ character for the Released column in order to break the yyyy-mm-dd in to its individual parts. For each pass I would check the first indice which corresponds to the year and then I would check if it was equal to the Year column for that specific movie if it was false I set the value to FALSE. Then I counted all of the instances where Gross in my dataframe all of which were not NA and multiplied the amount by .10 to get 10% which ended up being 452. Next I removed 452 of the rows where the released year and year did not match, I also made sure to drop all of the rows that had NA for the Release column.


## 5. Explore `Gross` revenue

For the commercial success of a movie, production houses want to maximize Gross revenue. Investigate if Gross revenue is related to Budget, Runtime or Genre in any way.

Note: To get a meaningful relationship, you may have to partition the movies into subsets such as short vs. long duration, or by genre, etc.

```{r plot1, fig.width=12, fig.height=12, echo=FALSE, warning=FALSE, message=FALSE}
# TODO: Investigate if Gross Revenue is related to Budget, Runtime or Genre
df = subset(df, !is.na(Gross))
total_gross_drama = sum(df$Gross[which(df$drama==1)])
total_gross_comedy = sum(df$Gross[which(df$comedy==1)])
total_gross_action= sum(df$Gross[which(df$action==1)])
total_gross_adventure = sum(df$Gross[which(df$adventure==1)])
total_gross_crime = sum(df$Gross[which(df$crime==1)])
total_gross_romance = sum(df$Gross[which(df$romance==1)])
total_gross_thriller = sum(df$Gross[which(df$thriller==1)])
total_gross_horror = sum(df$Gross[which(df$horror==1)])
total_gross_scifi = sum(df$Gross[which(df$scifi==1)])
total_gross_mystery = sum(df$Gross[which(df$mystery==1)])
total_gross_adult = sum(df$Gross[which(df$adult==1)])
total_gross_animation = sum(df$Gross[which(df$animation==1)])
total_gross_biography = sum(df$Gross[which(df$biography==1)])
total_gross_documentary = sum(df$Gross[which(df$documentary==1)])
total_gross_family = sum(df$Gross[which(df$family==1)])
total_gross_fantasy = sum(df$Gross[which(df$fantasy==1)])
total_gross_filmnoir = sum(df$Gross[which(df$filmnoir==1)])
total_gross_history = sum(df$Gross[which(df$history==1)])
total_gross_music = sum(df$Gross[which(df$music==1)])
total_gross_musical = sum(df$Gross[which(df$musical==1)])
total_gross_news = sum(df$Gross[which(df$news==1)])
total_gross_short = sum(df$Gross[which(df$short==1)])
total_gross_sport = sum(df$Gross[which(df$sport==1)])
total_gross_war = sum(df$Gross[which(df$war==1)])
total_gross_western = sum(df$Gross[which(df$western==1)])

genre_labels = c("drama", "comedy", "action", "adventure", "crime", "romance", "thriller", "horror", "scifi", "mystery",
                 "adult", "animation", "biography", "documentary", "family", "fantasy", "filmnoir", "history",
                 "music", "musical", "news", "short", "sport", "war", "western")
totals_gross_genre = c(total_gross_drama,
                                 total_gross_comedy,
                                 total_gross_adventure,
                                 total_gross_action,
                                 total_gross_crime,
                                 total_gross_romance,
                                 total_gross_thriller,
                                 total_gross_horror,
                                 total_gross_scifi,
                                 total_gross_mystery,
                       total_gross_adult, 
                       total_gross_animation,
                       total_gross_biography,
                       total_gross_documentary,
                       total_gross_family,
                       total_gross_fantasy, 
                       total_gross_filmnoir,
                       total_gross_history, 
                       total_gross_music, 
                       total_gross_musical,
                       total_gross_news,
                       total_gross_short,
                       total_gross_sport,
                       total_gross_war, 
                       total_gross_western)
gross_genere_totals = data.frame(genre=genre_labels, gross_Totals=totals_gross_genre)

ggplot(gross_genere_totals, aes(x = reorder(genre, -gross_Totals), y = gross_Totals)) + 
        geom_bar(stat="identity") + 
        labs(x="Genre",y="Gross Totals ($)") + 
        ggtitle("Gross Total ($) Vs. Genre") 


mean_gross_drama = mean(df$Gross[which(df$drama==1)])
mean_gross_comedy = mean(df$Gross[which(df$comedy==1)])
mean_gross_action= mean(df$Gross[which(df$action==1)])
mean_gross_adventure = mean(df$Gross[which(df$adventure==1)])
mean_gross_crime = mean(df$Gross[which(df$crime==1)])
mean_gross_romance = mean(df$Gross[which(df$romance==1)])
mean_gross_thriller = mean(df$Gross[which(df$thriller==1)])
mean_gross_horror = mean(df$Gross[which(df$horror==1)])
mean_gross_scifi = mean(df$Gross[which(df$scifi==1)])
mean_gross_mystery = mean(df$Gross[which(df$mystery==1)])
mean_gross_adult = mean(df$Gross[which(df$adult==1)])
mean_gross_animation = mean(df$Gross[which(df$animation==1)])
mean_gross_biography = mean(df$Gross[which(df$biography==1)])
mean_gross_documentary = mean(df$Gross[which(df$documentary==1)])
mean_gross_family = mean(df$Gross[which(df$family==1)])
mean_gross_fantasy = mean(df$Gross[which(df$fantasy==1)])
mean_gross_filmnoir = mean(df$Gross[which(df$filmnoir==1)])
mean_gross_history = mean(df$Gross[which(df$history==1)])
mean_gross_music = mean(df$Gross[which(df$music==1)])
mean_gross_musical = mean(df$Gross[which(df$musical==1)])
mean_gross_news = mean(df$Gross[which(df$news==1)])
mean_gross_short = mean(df$Gross[which(df$short==1)])
mean_gross_sport = mean(df$Gross[which(df$sport==1)])
mean_gross_war = mean(df$Gross[which(df$war==1)])
mean_gross_western = mean(df$Gross[which(df$western==1)])

genre_labels_mean = c("drama", "comedy", "action", "adventure", "crime", "romance", "thriller", "horror", "scifi", "mystery",
                 "adult", "animation", "biography", "documentary", "family", "fantasy", "filmnoir", "history",
                 "music", "musical", "news", "short", "sport", "war", "western")
mean_gross_genre = c(mean_gross_drama,
                       mean_gross_comedy,
                       mean_gross_adventure,
                       mean_gross_action,
                       mean_gross_crime,
                       mean_gross_romance,
                       mean_gross_thriller,
                       mean_gross_horror,
                       mean_gross_scifi,
                       mean_gross_mystery,
                       mean_gross_adult, 
                       mean_gross_animation,
                       mean_gross_biography,
                       mean_gross_documentary,
                       mean_gross_family,
                       mean_gross_fantasy, 
                       mean_gross_filmnoir,
                       mean_gross_history, 
                       mean_gross_music, 
                       mean_gross_musical,
                       mean_gross_news,
                       mean_gross_short,
                       mean_gross_sport,
                       mean_gross_war, 
                       mean_gross_western)
gross_genere_mean = data.frame(genre=genre_labels_mean, gross_Mean=mean_gross_genre)

ggplot(gross_genere_mean , aes(x = reorder(genre, -gross_Mean), y = gross_Mean)) + 
        geom_bar(stat="identity") + 
        labs(x="Genre",y="Gross Mean ($)") + 
        ggtitle("Gross Mean ($) Vs. Genre") 


df$timeInter = findInterval(df$Runtime, seq(0, 325, by = 25))
df$timeInter[df$timeInter==1] = '0-25'
df$timeInter[df$timeInter==2] = '25-50'
df$timeInter[df$timeInter==3] = '50-75'
df$timeInter[df$timeInter==4] = '75-100'
df$timeInter[df$timeInter==5] = '100-125'
df$timeInter[df$timeInter==6] = '125-150'
df$timeInter[df$timeInter==7] = '150-175'
df$timeInter[df$timeInter==8] = '175-200'
df$timeInter[df$timeInter==9] = '200-225'
df$timeInter[df$timeInter==10] = '225-250'
df$timeInter[df$timeInter==11] = '250-275'
df$timeInter[df$timeInter==12] = '275-300'
df$timeInter[df$timeInter==13] = '300-325'
df$timeInter[df$timeInter==14] = '325'



total_gross_0_25 =  sum(df$Gross[which(df$timeInter=='0-25')])
total_gross_25_50 = sum(df$Gross[which(df$timeInter=='25-50')])
total_gross_50_75 = sum(df$Gross[which(df$timeInter=='50-75')])
total_gross_75_100 = sum(df$Gross[which(df$timeInter=='75-100')])
total_gross_100_125 = sum(df$Gross[which(df$timeInter=='100-125')])
total_gross_125_250 = sum(df$Gross[which(df$timeInter=='125-150')])
total_gross_150_175 = sum(df$Gross[which(df$timeInter=='150-175')])
total_gross_175_200 = sum(df$Gross[which(df$timeInter=='175-200')])
total_gross_200_225 = sum(df$Gross[which(df$timeInter=='200-225')])
total_gross_225_250 = sum(df$Gross[which(df$timeInter=='225-250')])
total_gross_250_275 = sum(df$Gross[which(df$timeInter=='250-275')])
total_gross_275_300 = sum(df$Gross[which(df$timeInter=='275-300')])
total_gross_300_325 = sum(df$Gross[which(df$timeInter=='300-325')])
total_gross_325 = sum(df$Gross[which(df$timeInter=='325')])

time_interval_labels = c('0-25',
                '25-50',
                 '50-75',
                '75-100',
                '100-125',
               '125-150',
                '150-175',
                '175-200',
                '200-225',
                '225-250',
                '250-275',
                '275-300',
               '300-325',
               '325')
totals_gross_time = c(total_gross_0_25, 
                       total_gross_25_50, 
                       total_gross_50_75, 
                       total_gross_75_100, 
                       total_gross_100_125, 
                       total_gross_125_250,
                       total_gross_150_175,
                       total_gross_175_200,
                       total_gross_200_225,
                       total_gross_225_250, 
                       total_gross_250_275,
                       total_gross_275_300,
                       total_gross_300_325,
                       total_gross_325)

gross_time_totals = data.frame(time_interval_labels = time_interval_labels, gross_Totals = totals_gross_time)

ggplot(gross_time_totals, aes(x = reorder(time_interval_labels, -gross_Totals), y = gross_Totals)) + 
        geom_bar(stat="identity") + 
        labs(x="Runtime (Minutes)",y="Gross Totals") + 
        ggtitle("Gross Total ($) Vs. Runtime (Minutes)") 

#Mean
mean_gross_0_25 = mean(df$Gross[which(df$timeInter=='0-25')])
mean_gross_25_50 = mean(df$Gross[which(df$timeInter=='25-50')])
mean_gross_50_75 = mean(df$Gross[which(df$timeInter=='50-75')])
mean_gross_75_100 = mean(df$Gross[which(df$timeInter=='75-100')])
mean_gross_100_125 = mean(df$Gross[which(df$timeInter=='100-125')])
mean_gross_125_250 = mean(df$Gross[which(df$timeInter=='125-150')])
mean_gross_150_175 = mean(df$Gross[which(df$timeInter=='150-175')])
mean_gross_175_200 = mean(df$Gross[which(df$timeInter=='175-200')])
mean_gross_200_225 = mean(df$Gross[which(df$timeInter=='200-225')])
mean_gross_225_250 = mean(df$Gross[which(df$timeInter=='225-250')])
mean_gross_250_275 = mean(df$Gross[which(df$timeInter=='250-275')])
mean_gross_275_300 = mean(df$Gross[which(df$timeInter=='275-300')])
mean_gross_300_325 = mean(df$Gross[which(df$timeInter=='300-325')])
mean_gross_325 = mean(df$Gross[which(df$timeInter=='325')])

time_interval_mean_labels = c('0-25',
                         '25-50',
                         '50-75',
                         '75-100',
                         '100-125',
                         '125-150',
                         '150-175',
                         '175-200',
                         '200-225',
                         '225-250',
                         '250-275',
                         '275-300',
                         '300-325',
                         '325')
mean_gross_time = c(mean_gross_0_25, 
                      mean_gross_25_50, 
                      mean_gross_50_75, 
                      mean_gross_75_100, 
                      mean_gross_100_125, 
                      mean_gross_125_250,
                      mean_gross_150_175,
                      mean_gross_175_200,
                      mean_gross_200_225,
                      mean_gross_225_250, 
                      mean_gross_250_275,
                      mean_gross_275_300,
                      mean_gross_300_325,
                      mean_gross_325)
mean_time_totals = data.frame(time_interval_labels = time_interval_mean_labels, gross_Mean = mean_gross_time)
#KEEP
ggplot(mean_time_totals, aes(x = reorder(time_interval_labels, -gross_Mean), y = gross_Mean)) + 
        geom_bar(stat="identity") + 
        labs(x="Runtime (Minutes)",y="Gross Mean") + 
        ggtitle("Gross Mean ($) Vs. Runtime (Minutes)") +
        theme(axis.text.x=element_text(angle=45, hjust=1))

#USE as you can see most of the data points are to the left and the outliers are skewing the graph left so I decided to set a limit on the X axis for Gross.
ggplot(data=df,aes(x=Gross,y=Runtime))+
        geom_point(alpha=1/10,position="jitter")+
        scale_y_continuous(limits = c(0,250)) +
        ggtitle("Runtime (Minutes) Vs Gross") 

ggplot(data=df,aes(x=Gross,y=Runtime))+
        geom_point(alpha=1/10,position="jitter")+
        scale_y_continuous(limits = c(0,250)) +
        scale_x_continuous(name = "Gross", limits = c(0,35000000)) +
        ggtitle("Runtime (Minutes) Vs Gross ($): X-axis limited to 35M$") 


ggplot(data = df, aes(x = Gross, y = Budget)) + geom_point() +
        stat_smooth(color = "red", size = I(1), se = F) + 
        ggtitle("Gross ($) Vs Budget ($) Vs Runtime (Minutes)") +
        facet_wrap(~timeInter)



ggplot(df, aes(log10(df$Budget), log10(df$Gross))) + 
        geom_point() +  
        stat_smooth(color = "red", size = I(2), se = F) +
        ggtitle("Gross(log10) V. Budget(log10) Scatter Plot")

# USE
df$GenreCombined = ifelse(df$action == 1,"Action",
                          ifelse(df$comedy == 1,"Comedy",
                                 ifelse(df$drama == 1,"Drama",
                                        ifelse(df$adventure == 1,"Adventure",
                                               ifelse(df$crime == 1,"Crime",
                                                      ifelse(df$romance == 1,"Romance",
                                                             ifelse(df$thriller == 1,"Thriller",
                                                                    ifelse(df$horror == 1,"Horror",
                                                                           ifelse(df$scifi == 1,"Scifi",
                                                                                  ifelse(df$mystery == 1,"Mystery",NA))))))))))

df2 = subset(df, !is.na(df$GenreCombined))

plot1 = ggplot(df2, aes(log10(Budget), log10(Gross)))+ 
        geom_point() + 
        labs(x="Budget (log10)",y="Gross (log10)") +
        stat_smooth(color = "red", size = I(1), se = F) +
        ggtitle("Budget (log 10) Vs Gross (log 10) Faceted by Runtime and Genre") +
        facet_wrap(timeInter~GenreCombined)

plot(plot1)


```

**Q**: Did you find any observable relationships or combinations of Budget/Runtime/Genre that result in high Gross revenue? If you divided the movies into different subsets, you may get different answers for them - point out interesting ones.

**A**: You can see that budget and gross have a high positive correlation, if the movie has a higher budget it will have a higher gross. In the graph labeled “Gross Total ($) Vs. Runtime (Minutes)” what runtime groups most of the total gross is contained which is 100-125 min.
It should also be noted that in the graph labeled “Gross total ($) Vs. Genre” you can see the top 10 genres are also the in the top 10 grossing which isn’t very surprising, because there is more of those types of movies the sum of them would be greater than the genres were less produced, because of this fact I decided to find the mean totals.
In the “Gross mean Vs. Genre” barplot you can see that using the mean gives you a more accurate picture of the distribution of gross totals for each genre. I think it is interesting to see the difference in both.You can see how the top grossing runtime subsets shifted after I applied mean to gross in the graph titled “Gross Mean ($) Vs. Runtime (Minutes)".
In the graph labeled “Runtime (Minutes) Vs Gross”, most of the data points are to the left and the outliers are skewing the graph left so I decided to set a limit on the X axis for Gross.After constraining the X-axis in the graph “Runtime (Minutes) Vs Gross ($): X-axis limited to 35M($)" you can see clearly that there is a main cluster with movies that made around and are of runtime 75-110min. I next wanted to see if gross was related to budget and minutes.
With the graph labeled “Gross ($) Vs Budget ($) Vs Runtime (Minutes)” you can see a high positive correlation for budget and gross with the following times faceted by minute bins: 100-125, 125-150, 150-175, 175-200. The next graph I decided to see if there was a four-way relationship between gross, budget, runtime and genre in the graph labeled “Budget (log 10) Vs Gross (log 10) Faceted by Runtime and Genre)”. With this graph you can see what runtimes and genres are the most positively correlated with budget and gross. 

```{r}
# TODO: Investigate if Gross Revenue is related to Release Month
month_split = function(col1){
        seq_Col = seq_along(col1)
        split = c()
        for(i in seq_Col){
                split_On_Dashes = strsplit(as.character(df$Released[i]), '-')[[1]]
                split = append(split,as.numeric(split_On_Dashes)[2])
        }
        return (split)
}

month_split_numbers = month_split(df$Released)
df$monthReleased = month_split_numbers
df = subset(df, !is.na(df$monthReleased))

ggplot(df, aes((df$monthReleased), (df$Gross))) + 
        geom_bar(stat="identity") +  
        scale_x_continuous(name = "Month Released", breaks = seq(1, 12, by = 1)) +
        labs(y="Gross($)") +
        ggtitle("Gross($) Vs. Month Released") 

ggplot(df, aes(monthReleased, log10(df$Gross))) + 
        geom_point() + 
        scale_x_continuous(name = "Month Released", breaks = seq(1, 12, by = 1)) +
        stat_smooth(color = "red", size = I(2), se = F) +
        ggtitle("Gross(log10) V. Budget(log10) Scatter Plot")


```

## 6. Process `Awards` column

The variable `Awards` describes nominations and awards in text format. Convert it to 2 numeric columns, the first capturing the number of wins, and the second capturing nominations. Replace the `Awards` column with these new columns, and then study the relationship of `Gross` revenue with respect to them.

Note that the format of the `Awards` column is not standard; you may have to use regular expressions to find the relevant values. Try your best to process them, and you may leave the ones that don't have enough information as NAs or set them to 0s.

```{r}
# TODO: Convert Awards to 2 numeric columns: wins and nominations
wins = c()
nominations = c()
for(i in seq_along(df$Awards)){
        winsHolder = 0
        nominationsHolder = 0
        pattern1 ="((\\d*?) (wins|win))"
        pattern2 ="((\\d*?) (nominations|nomination))"
        pattern3 ="Nominated for ((\\d*?) (Primetime|Golden Globes|Golden Globe|Oscars|Oscar|BAFTA))"
        pattern4 = "Won ((\\d*?) (Primetime|Golden Globes|Golden Globe|Oscars|Oscar|BAFTA))"
        if((!is.na(as.numeric(str_match(df$Awards[i],pattern4)[1,3])))){
                winsHolder = winsHolder + as.numeric(str_match(df$Awards[i],pattern4)[1,3])
        }
        if((!is.na(as.numeric(str_match(df$Awards[i],pattern1)[1,3])))){
               winsHolder = winsHolder + as.numeric(str_match(df$Awards[i],pattern1)[1,3])
        }
        if ((!is.na(as.numeric(str_match(df$Awards[i],pattern3)[1,3])))){
                nominationsHolder = nominationsHolder + as.numeric(str_match(df$Awards[i],pattern3)[1,3])
        }
        if ((!is.na(as.numeric(str_match(df$Awards[i],pattern2)[1,3])))){
                nominationsHolder = nominationsHolder + as.numeric(str_match(df$Awards[i],pattern2)[1,3])
        }
        if (is.na(as.numeric(str_match(df$Awards[i],pattern1)[1,3])) & is.na(as.numeric(str_match(df$Awards[i],pattern4)[1,3])) ){
                winsHolder = 0
        }
        if (is.na(as.numeric(str_match(df$Awards[i],pattern3)[1,3])) & is.na(as.numeric(str_match(df$Awards[i],pattern2)[1,3]))){
                nominationsHolder = 0
        }
        wins = append(wins,winsHolder)
        nominations = append(nominations,nominationsHolder)
        winsHolder = 0
        nominationsHolder = 0
}

wins = data.frame(wins, df$imdbID)
colnames(wins)[2] = "imdbID"
nominations = data.frame(nominations, df$imdbID)
colnames(nominations)[2] = "imdbID"

df = merge(df,wins,by= "imdbID")
df = merge(df,nominations,by= "imdbID")
totalNonZeroValuesWinsorNominations = 0

for (i in seq_along(df$wins)){
        if(df$wins[i] > 0 || df$nominations[i] > 0){
                totalNonZeroValuesWinsorNominations = totalNonZeroValuesWinsorNominations + 1
        }
}

print (totalNonZeroValuesWinsorNominations)
```

**Q**: How did you construct your conversion mechanism? How many rows had valid/non-zero wins or nominations?

**A**: For this problem I used 4 regex groups:  "((\\d*?) (wins|win))",  "((\\d*?) (nominations|nomination))", Nominated for ((\\d*?) (Primetime|Golden Globes|Golden Globe|Oscars|Oscar|BAFTA))", "Won ((\\d*?) (Primetime|Golden Globes|Golden Globe|Oscars|Oscar|BAFTA))", I then searched each row in the Awards column and if there was a pattern that matched the digit and word groups I set up I would extract the number for each. After getting the number I put them into either won or nominations vectors, then put the two vectors created as columns in the dataframe. There were 3370 valid/non-zero wins or nominations.


```{r fig.width=12, fig.height=12, echo=FALSE}
# TODO: Plot Gross revenue against wins and nominations
ggplot(df, aes(df$Gross, df$wins)) + 
        geom_point() + 
        labs(x="Gross", y="Wins") +
        stat_smooth(color = "red", size = I(1), se = F) +
        ggtitle("Gross V. Wins") 

ggplot(df, aes(df$Gross, df$nominations)) + 
        geom_point() + 
        labs(x="Gross", y="Nominations") +
        stat_smooth(color = "red", size = I(1), se = F) +
        ggtitle("Gross V. Nominations") 


newdf = data.frame(df$Gross,df$wins,df$nominations) 


my_fn <- function(data, mapping, ...){
        p <- ggplot(data = data, mapping = mapping) + 
                geom_point() + 
                geom_smooth(method=loess, fill="red", color="red", ...) +
                geom_smooth(method=lm, fill="blue", color="blue", ...)
        p
}
#http://padamson.github.io/r/ggally/ggplot2/ggpairs/2016/02/16/multiple-regression-lines-with-ggpairs.html
ggpairs(newdf,columnLabels = c("Gross", "Wins", "Nominations"),
                title="Gross V Wins V Nominations", lower = list(continuous = my_fn))
#This graph is heavily skewed by outliers
ggplot(df,aes(df$wins,df$nominations)) + 
        geom_point(alpha=1/15, position="jitter", aes(size =df$Gross)) + 
        scale_x_continuous(name = "Wins") +
        scale_y_continuous(name = "Nominations") +
        ggtitle("Nominations V Wins V Gross")


#zoomed
ggplot(df,aes(df$wins,df$nominations)) + 
        geom_point(alpha=1/15, position="jitter", aes(size =df$Gross)) + 
        scale_x_continuous(name = "Wins", limits = c(0,50)) +
        scale_y_continuous(name = "Nominations", limits = c(0,50)) +
        ggtitle("Nominations V Wins V Gross Constrained by 50")
#zoomed
ggplot(df,aes(df$wins,df$nominations)) + 
        geom_point(alpha=1/15, position="jitter", aes(size =df$Gross)) + 
        scale_x_continuous(name = "Wins", limits = c(0,10)) +
        scale_y_continuous(name = "Nominations", limits = c(0,10)) +
        ggtitle("Nominations V Wins V Gross Constrained by 10")
```

**Q**: How does the gross revenue vary by number of awards won and nominations received?

**A**: You can see there is a positive correlation between gross revenue, nominations and awards. the more wins and nominations the more likely it will have a higher gross revenue.

## 7. Movie ratings from IMDb and Rotten Tomatoes

There are several variables that describe ratings, including IMDb ratings (`imdbRating` represents average user ratings and `imdbVotes` represents the number of user ratings), and multiple Rotten Tomatoes ratings (represented by several variables pre-fixed by `tomato`). Read up on such ratings on the web (for example [rottentomatoes.com/about](https://www.rottentomatoes.com/about) and [ www.imdb.com/help/show_leaf?votestopfaq](http:// www.imdb.com/help/show_leaf?votestopfaq)).

Investigate the pairwise relationships between these different descriptors using graphs.

```{r fig.width=12, fig.height=12, echo=FALSE}
# TODO: Illustrate how ratings from IMDb and Rotten Tomatoes are related
dfVotesRatingsUserVCritic = data.frame(df$imdbRating,df$imdbVotes, df$tomatoMeter, df$tomatoRating, df$tomatoReviews)
dfVotesRatingsUserVCritic = dfVotesRatingsUserVCritic[complete.cases(dfVotesRatingsUserVCritic),]
ggpairs(dfVotesRatingsUserVCritic,columnLabels = c("IMDB-Rating", "IMDB-Votes", "Tomato-Meter", "Tomato-Rating","Tomato-Reviews"),
        title="IMDB V Rotten Tomatoes Critics", lower = list(continuous = my_fn))

dfVotesRatingsUserVUser = data.frame(df$imdbRating,df$imdbVotes, df$tomatoUserMeter, df$tomatoUserRating, df$tomatoUserReviews)
dfVotesRatingsUserVUser = dfVotesRatingsUserVUser[complete.cases(dfVotesRatingsUserVUser),]
ggpairs(dfVotesRatingsUserVUser,columnLabels = c("IMDB-Rating", "IMDB-Votes", "Tomato-UserMeter", "Tomato-UserRating","Tomato-UserReviews"),
        title="IMDB V Rotten Tomatoes Users", lower = list(continuous = my_fn))

```

**Q**: Comment on the similarities and differences between the user ratings of IMDb and the critics ratings of Rotten Tomatoes.

**A**: IMBD rating – Average user vote rating 1-10
IMDB Votes - # of users who voted for the movie
Tomato Meter – represents the percentage of professional critic reviews that are positive for a given film or television show.
Tomato Rating – Average ratings that critics have given
Tomato Reviews - # of professional critic reviews counted
TomatoUserMeter – percent positive for user reviews
TomatoUserRating – ratings from users of rotten Tomatoes
TomatoUserReviews - # of user reviews

You can similarities and differences between the user ratings of IMDB and the critics ratings of Rotten Tomatoes. We can see that the correlation between the critic tomato ratings and the IMDB ratings is .80 which means that they are both highly correlated. We can also see that the correlation between IMDM-Ratings and IMDB-Votes is .47 which means that the number of votes per movie could affect the rating of the movie. On the other hand, the correlation between the number of tomato reviews and tomato rating is .217 which means that the number of votes casted per movie does not have as much influence over the rating like IMDB has. The correlation between the tomato-meter and IMDB-rating is .76 which also shows a pretty high correlation that a high tomato-meter score means that an IMDB rating will most likely also be high.


## 8. Ratings and awards

These ratings typically reflect the general appeal of the movie to the public or gather opinions from a larger body of critics. Whereas awards are given by professional societies that may evaluate a movie on specific attributes, such as artistic performance, screenplay, sound design, etc.

Study the relationship between ratings and awards using graphs (awards here refers to wins and/or nominations). 

```{r fig.width=12, fig.height=12, echo=FALSE, warning=FALSE, message=FALSE}
# TODO: Show how ratings and awards are related
 dfAwardsRatingsIMDBUser = data.frame(df$wins, df$nominations,df$imdbRating,df$imdbVotes)
 ggpairs(dfAwardsRatingsIMDBUser, columnLabels = c("Wins", "Nominations", "IMDB-Rating", "IMDB-Votes"),
         title="IMDB V Wins V Nominations", lower = list(continuous = my_fn))
 
 dfAwardsRatingsRottenCritics = data.frame(df$wins, df$nominations,df$tomatoMeter, df$tomatoRating, df$tomatoReviews)
 ggpairs(dfAwardsRatingsRottenCritics, columnLabels = c("Wins", "Nominations", "Tomato Meter", "Tomato Rating", "Tomato Reviews"),
         title="Rotten Tomatoes Critics V Wins V Nominations", lower = list(continuous = my_fn))
 
 
 dfAwardsRatingsRottenUsers = data.frame(df$wins, df$nominations, df$tomatoUserMeter, df$tomatoUserRating, df$tomatoUserReviews)
 ggpairs(dfAwardsRatingsRottenCritics, columnLabels = c("Wins", "Nominations", "Tomato-UserMeter", "Tomato-UserRating","Tomato-UserReviews"),
         title="Rotten Tomatoes Users V Wins V Nominations", lower = list(continuous = my_fn))
```

**Q**: How good are these ratings in terms of predicting the success of a movie in winning awards or nominations? Is there a high correlation between two variables?

**A**: 
There seems to be a high postive correlation between critic reviews in regards to wins and nominations as well as a high postive correlation user reviews in regards to wins and nominations. Shwoing that high reviews are a good indicator between if the movie won awards or nominations, the higher amount of high rated reviews the more wins and/or nomiations a movie will have.

## 9. Expected insights

Come up with two new insights (backed up by data and graphs) that is expected. Here “new” means insights that are not an immediate consequence of one of the above tasks. You may use any of the columns already explored above or a different one in the dataset, such as `Title`, `Actors`, etc.

```{r}
# TODO: Find and illustrate two expected insights
 ggplot(data=df,aes(x=Year,y=df$imdbRating))+
         geom_bar(stat = "identity")+
         scale_x_continuous(name = "Years by Decade", breaks = seq(1888, 2018, by = 10)) +
         ggtitle("IMDB Rating count V. Decades") 

language = as.data.frame(table(df$Language))
language = language[order(language$Freq),] 

ggplot(language, aes(x = reorder(factor(Var1), Freq), y = Freq)) + 
        geom_bar(stat = "identity") + 
        labs(x="Languages") +
        ggtitle("Feq of languages in Movies") 

language  = language[491:498, ]

ggplot(language, aes(x = reorder(factor(Var1), Freq), y = Freq)) + 
        geom_bar(stat = "identity") + 
        labs(x="Languages") +
        ggtitle("Feq of top 8 languages in Movies")
```

**Q**: Expected insight #1. There are more reviews on IMDB for more recent decades because more people had acess to the internet and there were also more movies made in more recent decades which would mean there would be more reviews.

**A**: 
I was correct the graph shows a strong right skew towards more recent decades in the distribution of IMDB ratings.

**Q**: Expected insight #2. I expect that most of the movies are going to be made in the English language.
**A**: 
My assumption was correct that there are far more movies made in the English language than any other language by a large margin.

## 10. Unexpected insight

Come up with one new insight (backed up by data and graphs) that is unexpected at first glance and do your best to motivate it. Same instructions apply as the previous task.

```{r}
# TODO: Find and illustrate one unexpected insight
ratings_String = function(col){
        length_Col = seq_along(col)
        ratings = c()
        for(i in length_Col){
                if(grepl("APPROVED|UNRATED|PASSED|NOT RATED|N/A", df$Rated[i])){
                        ratings = append(ratings, NA)
                }
                else {
                        ratings = append(ratings,df$Rated[i])
                }
        }
        return (ratings)
}

rated_movies_with_na = data.frame(ratings_String(df$Rated))
rated_movies_with_na = data.frame(rated_movies_with_na, df$imdbID)
colnames(rated_movies_with_na)[1] = "Rated"
colnames(rated_movies_with_na)[2] = "imdbID"

rated_movies_with_na_merged = merge(df,rated_movies_with_na,by= "imdbID")

dfRatings = rated_movies_with_na_merged[-c(4)]
colnames(dfRatings)[68] = "Rated"
dfRatings = subset(dfRatings, !is.na(dfRatings$Rated))

ggplot(data=dfRatings,aes(x=Rated,y=Gross))+
        geom_point(alpha=1/10,position="jitter")+
        ggtitle("Gross ($) Vs. Movie Ratings") 

sumRRated = mean(dfRatings$Gross[which(dfRatings$Rated=='R')])
sumPG13Rated = mean(dfRatings$Gross[which(dfRatings$Rated=='PG-13')])
sumPGRated = mean(dfRatings$Gross[which(dfRatings$Rated=='PG')])
sumGRated = mean(dfRatings$Gross[which(dfRatings$Rated=='G')])
sumMRated = mean(dfRatings$Gross[which(dfRatings$Rated=='M')])
sumNC17Rated = mean(dfRatings$Gross[which(dfRatings$Rated=='NC-17')])
sumGPRated = mean(dfRatings$Gross[which(dfRatings$Rated=='GP')])
sumTV14Rated = mean(dfRatings$Gross[which(dfRatings$Rated=='TV-14')])
sumTVGRated = mean(dfRatings$Gross[which(dfRatings$Rated=='TV-G')])
sumTVPGRated = mean(dfRatings$Gross[which(dfRatings$Rated=='TV-PG')])
sumXRated = mean(dfRatings$Gross[which(dfRatings$Rated=='X')])

rated_mean_labels = c('R',
                        'PG-13',
                        'PG',
                        'G',
                        'M',
                        'NC-17',
                        'GP',
                        'TV-14',
                        'TV-G',
                        'TV-PG',
                         'X')

mean_gross_rated = c(sumRRated, 
                     sumPG13Rated, 
                     sumPGRated, 
                     sumGRated, 
                     sumMRated, 
                     sumNC17Rated,
                     sumGPRated,
                     sumTV14Rated,
                     sumTVGRated,
                     sumTVPGRated,
                     sumXRated)

mean_rating_totals = data.frame(Rating_Labels = rated_mean_labels, Gross_Mean = mean_gross_rated)


ggplot(mean_rating_totals, aes(x = reorder(Rating_Labels, -Gross_Mean), y = Gross_Mean)) + 
        geom_bar(stat="identity") + 
        labs(x="Ratings",y="Gross") + 
        ggtitle("Gross Mean Totals ($) Vs. Movie Ratings") 
```

**Q**: Unexpected insight. Ratings i.e (R, PG-13 ect) and gross profits.

**A**: I totaled the mean for each of the ratings groups and you can clearly see that G rated movies made the most money which I did not expect at first glance of the data.

